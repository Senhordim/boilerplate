/// SQLite Data do model Animal
///
/// Os Métodos padrões gerados são:
///     fecthAll() -> Recupera a lista de Animal.
///     save() -> Salva os dados de uma instância do Animal.
///     detail() -> Recupera os detalhes de Animal.
///     update() -> Atualiza os dados de uma instância do Animal.
///     delete() -> Deleta um registro.
///     deleteAll() -> Deleta todos os registros.

/// [Travar o arquivo]
/// Caso deseje "travar" o arquivo para não ser parseado novamente
/// pelo manage do Django adicione um # antes da palavra abaixo
/// FileLocked

import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'model.dart';

$ParametersTable$

class $ModelClass$Data {
  static final $ModelClass$Data _instance = $ModelClass$Data.internal();

  factory $ModelClass$Data() => _instance;

  $ModelClass$Data.internal();

  // Iniciando o objeto DataBase
  Database _db;

  Future<Database> get db async {
    if (_db != null) {
      return _db;
    } else {
      _db = await initDb();
      return _db;
    }
  }

  // Método para inicialiar o banco de dados criando a tabela.
  Future<Database> initDb() async {
    try {
      final _dbPath = await getDatabasesPath();
      final _path = join(_dbPath, "$project$.db");
      return await openDatabase(_path, version: 1,
          onCreate: (Database db, int newerVersion) async {
        await db.execute($CreateTable$);
      });
    } catch (error, exception) {
      return throw {"error": error, "message": exception};
    }
  }

  // Método para salvar o $ModelClass$Model no SQLite
  Future<$ModelClass$Model> save($ModelClass$Model $Model$) async {
    try {
      Database _db = await db;
      $Model$.idSqLite = await _db.insert($Model$Table, $Model$.toJson());
      return $Model$;
    } catch (error, exception) {
      return throw {"error": error, "message": exception};
    }    
  }

  // Método para retornar todos os elementos de $ModelClass$Model no SQLite
  Future<List<$ModelClass$Model>> fetchAll() async {
    try {
      List<$ModelClass$Model> _$Model$List;
      Database _db = await db;
      var _result = await _db.query("$$Model$Table");
      _$Model$List = _result.isNotEmpty 
          ? _result.map(($Model$) => $ModelClass$Model.fromJson($Model$)).toList() 
          : [];
      return _$Model$List;
    } catch (error, exception) {
      return throw {"error": error, "message": exception};
    }
  }
  
  // Método para retonar um elemento de $ModelClass$Model no SQLite
  Future<$ModelClass$Model> detail(int id) async {
    try {
      Database _db = await db;
      var _result = await _db.query($Model$Table, where: "$id = ?", whereArgs: [id]);
      return _result.isNotEmpty 
          ? $ModelClass$Model.fromJson(_result.first) 
          : Null;
    } catch (error, exception) {
      return throw {"error": error, "message": exception};
    }    
  }

  // Método para atualizar o $ModelClass$ no SQLite
  update($ModelClass$Model $Model$) async {
    try {
      Database _db = await db;
      return await _db.update($Model$Table,
          $Model$.toJson(), where: "$id = ?", whereArgs: [$Model$.id]);
    } catch (error, exception) {
      return throw {"error": error, "message": exception};
    }
  }

  // Método para excluir o $ModelClass$ no SQLite
  Future<int> delete(int id) async {
    try {
      Database _db = await db;
      return await _db.delete($Model$Table, where: "$id = ?", whereArgs: [id]);
    } catch (error, exception) {
      return throw {"error": error, "message": exception};
    }    
  }

  // Método para excluir o $ModelClass$ no SQLite
  Future<int> deleteAll() async {
    try {
      Database _db = await db;
      return await _db.delete($Model$Table);
    } catch (error, exception) {
      return throw {"error": error, "message": exception};
    }    
  }
}